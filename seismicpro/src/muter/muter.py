"""Implements Muter class to define a boundary above which gather values will be zeroed out"""

import numpy as np

from .utils import compute_crossovers_times
from ..utils import to_list, VFUNC


class Muter(VFUNC):
    """A class to define an offset-time boundary above which gather values will be muted i.e. zeroed out.

    Usually muting is performed to attenuate any strong, coherent noise that was generated by the shot, e.g. high
    amplitudes near the first breaks. Such kind of noise strongly affects several processing routines, such as
    :func:`~Gather.calculate_semblance`.

    A muter object can be created from three different types of data by calling a corresponding `classmethod`:
    * `from_points` - create a muter from 1d arrays of offsets and times,
    * `from_file` - create a muter from a file in VFUNC format with offset-time pairs,
    * `from_first_breaks` - create a muter from 1d arrays of offsets and times of first breaks.

    The created object is callable and returns times up to which muting should be performed for given offsets. If a
    muter is created by direct instantiation, zero time will be returned for every offset.

    Examples
    --------
    >>> muter = Muter.from_points(offsets=[100, 1000, 2000], times=[200, 2000, 3000])
    >>> muter([0, 100, 500, 1000, 1500, 2000])
    array([   0.,  200., 1000., 2000., 2500., 3000.])

    Attributes
    ----------
    muter : callable
        Return muting times for given offsets. `muter` argument must be either numeric or 1d array-like.
    """
    def __init__(self, offsets, times, coords=None):
        super().__init__(offsets, times, coords=coords)

    @property
    def offsets(self):
        return self.data_x

    @property
    def times(self):
        return self.data_y

    @classmethod
    def from_refractor_velocity(cls, refractor_velocity, delay=0, velocity_reduction=0):
        """Create a muter from 1d arrays of offsets and times of first breaks.

        The muter estimates seismic wave velocity in the weathering layer using linear regression, decrements it by
        `velocity_reduction` in order to attenuate amplitudes immediately following the first breaks and uses the
        resulting velocity to get muting times by offsets passed.

        Parameters
        ----------
        offsets : 1d array-like
            An array with offset values. Measured in meters.
        times : 1d array-like
            An array with times of first breaks, matching the length of `offsets`. Measured in milliseconds.
        velocity_reduction : float, optional, defaults to 0
            A value used to decrement the found velocity in the weathering layer to attenuate amplitudes immediately
            following the first breaks. Measured in meters/seconds.

        Returns
        -------
        self : Muter
            Created muter.
        """
        times, offsets = refractor_velocity.piecewise_times, refractor_velocity.piecewise_offsets
        offsets_diff = np.diff(offsets)
        muting_velocities = offsets_diff / np.diff(times) - velocity_reduction / 1000  # m/ms
        time_deltas = np.empty_like(times)
        time_deltas[0] = times[0] + delay
        time_deltas[1:] = offsets_diff / muting_velocities
        return cls(offsets, np.cumsum(time_deltas), coords=refractor_velocity.coords)

    @classmethod
    def from_muters(cls, muters, weights=None, coords=None):
        muters = to_list(muters)
        if weights is None:
            weights = np.ones_like(muters) / len(muters)
        weights = np.array(weights)
        offsets = np.unique(np.concatenate([mut.offsets for mut in muters]))
        times = (np.stack([mut(offsets) for mut in muters]) * weights[:, None]).sum(axis=0)
        return cls(offsets, times, coords=coords)

    @classmethod
    def from_stacking_velocity(cls, stacking_velocity, stretch_factor=0.65):
        """ docs """
        stretch_offsets = (stacking_velocity.velocities / 1000) * stacking_velocity.times * np.sqrt((1 + stretch_factor)**2 - 1)
        return cls(stretch_offsets, stacking_velocity.times, coords=stacking_velocity.coords)
