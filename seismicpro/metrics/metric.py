"""Implements base class for metric calculation"""

from copy import deepcopy
from textwrap import dedent

from .metric_map import MetricMap
from ..utils import to_list, get_first_defined


class Metric:
    """Define a metric and its calculation logic.

    A metric is usually used as a class, not an instance: a concrete metric class must be inherited from `Metric`. It
    describes a metric as a function and must implement an obligatory `calc` classmethod and various class attributes
    that store metric metadata (e.g its name and minimum and maximum values).

    The simplest way to calculate the defined metric is by manually iterating over a dataset and calling `calc` method.
    However, convenient interfaces for most common calculation cases exist e.g. `SeismicBatch.calculate_metric` method
    simplifies metric accumulation over batches of data in a global storage.

    If spatial coordinated are known for each calculated metric value (e.g. the metric is the quality of noise
    attenuation for a shot gather and coordinates are `SourceX` and `SourceY`), they can be used to create an instance
    of a `MetricMap` which allows for metric visualization over a field. Such plot may optionally be interactive:
    clicking on it may display some data representation at the click location (it may be the gather before and after
    attenuation in the provided example). This behavior is defined by views: metric methods that accept click
    coordinates and axes to plot on. These methods should be listed in `views` attribute to be automatically detected
    by a map class.

    Each view must be able to obtain data for visualization by click coordinates, which requires knowledge of the
    metric calculation context. This can be achieved by instantiating the metric: all keyword arguments passed to
    `__init__` are stored as instance attributes and can be accessed by views to generate visualization data on request
    without explicitly keeping reference on it.

    Thus, in order to define a metric, one needs to:
    * create a class inherited from `Metric`,
    * implement `calc` method,
    * set metric `name` and optionally other class attributes,
    * optionally implement one or more views and list them in the `views` attribute,
    * optionally redefine `__init__` method if some complex processing is required.

    Attributes
    ----------
    name : str or None
        Metric name. It is used in internal data structures (e.g. `MetricsAccumulator`) to identify the metric and is
        displayed in a metric map title.
    min_value : float or None
        Minimum metric value. If given, limits the colorbar of the metric map.
    max_value : float or None
        Maximum metric value. If given, limits the colorbar of the metric map.
    is_lower_better : bool or None
        Specifies if lower value of the metric is better. Affects the default aggregation of the metric and the map
        colormap.
    map_class : type
        A type of the metric map generated by `MetricsAccumulator.construct_map`. Defaults to `MetricMap`.
    vmin : float or None
        Minimum colorbar value. Unlike `min_value` which describes theoretical minimum value of the metric in
        mathematical sense, `vmin` defines colorbar limit to compare several maps or highlight outliers. Takes
        precedence over `min_value`.
    vmax : float or None
        Maximum colorbar value. Unlike `max_value` which describes theoretical maximum value of the metric in
        mathematical sense, `vmax` defines colorbar limit to compare several maps or highlight outliers. Takes
        precedence over `max_value`.
    views : str or iterable of str
        Default views of the metric to display on click on a metric map in interactive mode. No default views are
        defined.
    """
    name = "metric"
    is_lower_better = None
    min_value = None
    max_value = None

    map_class = MetricMap
    views = tuple()
    vmin = None
    vmax = None

    def __init__(self, name=None):
        if name is not None:
            if not isinstance(name, str):
                raise TypeError("Metric name name must be a string")
            self.name = name
        self.has_bound_context = False

    def __call__(self, *args, **kwargs):
        """Calculate the metric. Must be overridden in child classes."""
        _ = self, args, kwargs
        raise NotImplementedError

    def __repr__(self):
        """String representation of the metric."""
        return f"{type(self).__name__}(name='{self.name}')"

    def __str__(self):
        msg = f"""
        Metric type:               {type(self).__name__}
        Metric name:               {self.name}
        Is lower value better:     {get_first_defined(self.is_lower_better, "Undefined")}
        Minimum metric value:      {get_first_defined(self.min_value, "Undefined")}
        Maximum metric value:      {get_first_defined(self.max_value, "Undefined")}

        Metric map visualization parameters:
        Knows evaluation context:  {self.has_bound_context}
        Metric map type:           {self.map_class.__name__}
        Number of metric views:    {len(self.views)}
        Minimum displayed value:   {get_first_defined(self.vmin, "Undefined")}
        Maximum displayed value:   {get_first_defined(self.vmax, "Undefined")}
        """
        return dedent(msg).strip()

    def info(self):
        print(self)

    def bind(self, metric_map):
        _ = metric_map
        return self

    def bind_context(self, metric_map, **kwargs):
        if self.has_bound_context:
            return self

        # Copy the metric to handle the case when it is simultaneously used in multiple maps
        self_bound = deepcopy(self).bind(metric_map=metric_map, **kwargs)
        self_bound.has_bound_context = True
        return self_bound

    def get_views(self, **kwargs):
        """Return plotters of the metric views and those `kwargs` that should be passed further to an interactive map
        plotter."""
        return [getattr(self, view) for view in to_list(self.views)], kwargs

    def construct_map(self, coords, values, *, coords_cols=None, index=None, index_cols=None, agg=None, bin_size=None,
                      calculate_immediately=True, **context):
        return self.map_class(coords, values, coords_cols=coords_cols, index=index, index_cols=index_cols, metric=self,
                              agg=agg, bin_size=bin_size, calculate_immediately=calculate_immediately, **context)


def is_metric(metric, metric_class=Metric):
    return isinstance(metric, metric_class) or isinstance(metric, type) and issubclass(metric, metric_class)


def initialize_metrics(metrics, metric_class=Metric):
    is_single_metric = is_metric(metrics, metric_class=metric_class)
    metrics = to_list(metrics)
    if not metrics:
        raise ValueError("At least one metric should be passed")
    if not all(is_metric(metric, metric_class=metric_class) for metric in metrics):
        raise TypeError(f"All passed metrics must be either instances or subclasses of {metric_class.__name__}")
    if len({metric.name for metric in metrics}) != len(metrics):
        raise ValueError("Passed metrics must have different names")
    metrics = [metric() if isinstance(metric, type) else metric for metric in metrics]
    return metrics, is_single_metric
