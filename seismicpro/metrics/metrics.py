"""Implements base classes for metric calculation"""

from .metric_map import MetricMap
from ..utils import to_list


class Metric:
    """Define a metric and its calculation logic.

    A metric is usually used as a class, not an instance: a concrete metric class must be inherited from `Metric`. It
    describes a metric as a function and must implement an obligatory `calc` classmethod and various class attributes
    that store metric metadata (e.g its name and minimum and maximum values).

    The simplest way to calculate the defined metric is by manually iterating over a dataset and calling `calc` method.
    However, convenient interfaces for most common calculation cases exist e.g. `SeismicBatch.calculate_metric` method
    simplifies metric accumulation over batches of data in a global storage.

    If spatial coordinated are known for each calculated metric value (e.g. the metric is the quality of noise
    attenuation for a shot gather and coordinates are `SourceX` and `SourceY`), they can be used to create an instance
    of a `MetricMap` which allows for metric visualization over a field. Such plot may optionally be interactive:
    clicking on it may display some data representation at the click location (it may be the gather before and after
    attenuation in the provided example). This behavior is defined by views: metric methods that accept click
    coordinates and axes to plot on. These methods should be listed in `views` attribute to be automatically detected
    by a map class.

    Each view must be able to obtain data for visualization by click coordinates, which requires knowledge of the
    metric calculation context. This can be achieved by instantiating the metric: all keyword arguments passed to
    `__init__` are stored as instance attributes and can be accessed by views to generate visualization data on request
    without explicitly keeping reference on it.

    Thus, in order to define a metric, one needs to:
    * create a class inherited from `Metric`,
    * implement `calc` method,
    * set metric `name` and optionally other class attributes,
    * optionally implement one or more views and list them in the `views` attribute,
    * optionally redefine `__init__` method if some complex processing is required.

    Attributes
    ----------
    name : str or None
        Metric name. It is used in internal data structures (e.g. `MetricsAccumulator`) to identify the metric and is
        displayed in a metric map title.
    min_value : float or None
        Minimum metric value. If given, limits the colorbar of the metric map.
    max_value : float or None
        Maximum metric value. If given, limits the colorbar of the metric map.
    is_lower_better : bool or None
        Specifies if lower value of the metric is better. Affects the default aggregation of the metric and the map
        colormap.
    map_class : type
        A type of the metric map generated by `MetricsAccumulator.construct_map`. Defaults to `MetricMap`.
    vmin : float or None
        Minimum colorbar value. Unlike `min_value` which describes theoretical minimum value of the metric in
        mathematical sense, `vmin` defines colorbar limit to compare several maps or highlight outliers. Takes
        precedence over `min_value`.
    vmax : float or None
        Maximum colorbar value. Unlike `max_value` which describes theoretical maximum value of the metric in
        mathematical sense, `vmax` defines colorbar limit to compare several maps or highlight outliers. Takes
        precedence over `max_value`.
    views : str or iterable of str
        Default views of the metric to display on click on a metric map in interactive mode. No default views are
        defined.
    """
    name = None
    min_value = None
    max_value = None
    is_lower_better = None
    map_class = MetricMap
    vmin = None
    vmax = None
    views = tuple()

    def __init__(self, **kwargs):
        for key, val in kwargs.items():
            setattr(self, key, val)

    @classmethod
    def calc(cls, *args, **kwargs):
        """Calculate the metric. Must be overridden in child classes."""
        _ = cls, args, kwargs
        raise NotImplementedError

    def get_views(self, **kwargs):
        """Return plotters of the metric views and those `kwargs` that should be passed further to an interactive map
        plotter."""
        return [getattr(self, view) for view in to_list(self.views)], kwargs

    @staticmethod
    def combine_init_params(*params):
        """Combine metric parameters memorized for different batches of data into a single `dict` of keyword arguments.
        Should be redefined in child metric classes if complex accumulation logic is reqired, returns the last
        parameters `dict` by default."""
        return params[-1]


class PartialMetric:
    """Return an object which behaves like `Metric` but memorizes keyword arguments `kwargs` for further instantiation.

    Metric instantiation may be very time-consuming, that's why it is performed only during first interactive plotting
    of its map. `PartialMetric` allows conveniently memorizing arguments for metric `__init__` and postpone its call
    until the metric instance is actually needed. Moreover, `PartialMetric` can be applied to another `PartialMetric`,
    so that processing methods may consequently add new arguments.
    """
    def __init__(self, metric, **kwargs):
        if isinstance(metric, type) and issubclass(metric, Metric):
            self.metric_type = metric
            self._kwargs = [kwargs]
        elif isinstance(metric, PartialMetric):
            self.metric_type = metric.metric_type
            self._kwargs = [{**metric.kwargs, **kwargs}]
        else:
            raise ValueError("metric must be either an instance of PartialMetric or a subclass of Metric")

    @property
    def kwargs(self):
        """dict: keyword arguments memorized for future metric instantiation."""
        if len(self._kwargs) > 1:
            self._kwargs = [self.metric_type.combine_init_params(*self._kwargs)]
        return self._kwargs[0]

    def __getattr__(self, name):
        """Get a value of metric attribute either from memorized parameters or its class attributes."""
        if name in self.kwargs:
            return self.kwargs[name]
        return getattr(self.metric_type, name)

    def __call__(self, *args, **kwargs):
        """Instantiate a metric using memorized and passed parameters."""
        kwargs = {**self.kwargs, **kwargs}
        return self.metric_type(*args, **kwargs)

    def update(self, other):
        """Combine memorized parameters of `self` and `other` and store them in `self`."""
        self._kwargs += other._kwargs  # pylint: disable=protected-access


def define_metric(cls_name="MetricPlaceholder", base_cls=Metric, **kwargs):
    """Define a metric class called `cls_name` inherited from `base_cls` whose attributes and methods are stored in
    `kwargs`."""
    return type(cls_name, (base_cls,), kwargs)
